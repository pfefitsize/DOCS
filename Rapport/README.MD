# Rapport final

## Rappel du sujet

### Contexte

L'avènement des boutiques de prêt à porter en ligne à apporter de nouveaux besoins aux consommateurs. La solution FitSize a été imaginée pour répondre à ces besoins en facilitant au maximum le choix de la taille de nos vêtements de rêve et en limitant le nombre de retours.

### Présentation de la solution

La solution FitSize comme nous l’avons imaginé est composé de 3 applications :
Une application mobile permettant à l’utilisateur d’enregistrer ses modèles. L’utilisateur sera amené à prendre une photo de son vêtement accompagné d’un objet témoin (carte de crédit, pièce de monnaie…) sur une surface plane. Il indiquera ensuite la dimension de l’objet témoin ainsi que ses limites en plaçant 2 points sur l’image. Enfin, il placera des points de repères déterminant les dimensions de l’habit en se basant sur une photo guide.
Un serveur où seront effectués les calculs et qui enregistrera les données dans la base de données.
Un plugin web qui permet à un utilisateur de trouver la taille idéale pour le modèle qu’il consulte sur un site marchand.

Au cours de ce projet, nous avons travaillé sur l'application mobile ainsi que le backend, mais pas sur le plugin web.

## Architecture technique



## Résolution technique

## Gestion de projet

### Suivi de projet

Tout au long de ce projet, nous avons rempli un document répertoriant nos avancées du jour, nos blocages, nos interrogations…

### Conception

Nous avons débuté ce projet par une phase de conception, au cours de laquelle nous avons exploré de nombreuses solutions techniques potentiellement intéressantes pour notre application. Nous avons effectué plusieurs brainstorming lors de cette phase afin d’amplifier notre créativité et découvrir des solutions innovantes.

### Backlog

Une fois la phase de conception terminée, nous avons mis en place un backlog afin de répertorier les différentes tâches nécessaires à la réalisation de ce projet. Pour chaque tâche, nous avons associé une quantité d’effort estimée ainsi qu’une priorité.

### Division des tâches

Un fois le backlog écrit, nous avons pu nous répartir les tâches. Téva Geitner a travaillé sur l’application mobile tandis que Yaël Para et Jules Gonzalez ont travaillé sur la partie backend. Au sein du backend, le travail a également été réparti pour la découverte de Django Rest Framework ainsi que pour la mise en place de l’application.

### Github

Nous avons utilisé l’outil github afin de partager le code et les documents produits. 3 dépôts ont été ouverts, le premier pour la documentation, le second pour l’application mobile (frontend) et le troisième pour le serveur (backend). Nous avons utilisé de nouvelles branches pour chaque fonctionnalité, et avons effectué des revus de code à chaque merge vers la branche principale.

### Pair programming

Pour certaines tâches, comme le calcul des dimensions et l’enregistrement du modèle utilisateur, nous avons travaillé en pair programming. Pour ce faire, nous avons mis en place des sessions de programmation partagée via l’extension Live Share présente dans visual studio code. Ces sessions nous ont permis de travailler sur le même code depuis deux machines différentes, et d’expliquer certains points de manière beaucoup plus efficace grâce à la fonction de suivi qui permet de voir les actions des autres participants en temps réel.

### Communication interne

Nous avons utilisé l’outil Discord pour la communication interne à notre équipe. Un canal vocal nous a servi quand nous travaillions à distance, et des canaux écrits étaient présents pour notifier les autres de nos avancés et blocages dans les différentes parties du projet.

### Communication client

Notre communication avec le client s’est principalement effectuée à travers des réunions bihebdomadaires à travers le service Google Meet. Ces réunions duraient entre 30 et 60 minutes. Elles avaient pour objectif de tenir le client au courant de nos avancées, de discuter des choix techniques que nous devions prendre et d’obtenir un feedback sur notre travail.

## Outils

## Métriques logiciels

## Conclusion
